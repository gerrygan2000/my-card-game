<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏äÊµ∑Âπ≤Áû™Áúº (Final Network Edition)</title>
    <!-- ÂºïÂÖ• PeerJS -->
    <script src="https://cdn.staticfile.net/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
        /* ==================== 1. THEME & VARIABLES ==================== */
        :root {
            --bg-deep-wood: #1a1a1a;
            --table-overlay: rgba(0, 0, 0, 0.3);
            --neon-cyan: #00fff2;
            --neon-pink: #ff00de;
            --vintage-gold: #d4af37;
            --paper-yellow: #fdfbf7;
            --card-width: 64px;
            --card-height: 96px;
            --card-radius: 6px;
            --shadow-card: 2px 2px 4px rgba(0,0,0,0.4);
        }

        /* ==================== 2. GLOBAL LAYOUT ==================== */
        body {
            font-family: 'Songti SC', 'SimSun', serif; 
            margin: 0; overflow: hidden; height: 100vh; width: 100vw;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
            color: #e0e0e0; background-color: var(--bg-deep-wood);
        }

        #game-table-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('https://images.unsplash.com/photo-1533090161767-e6ffed986c88?q=80&w=2069');
            background-size: cover; background-position: center; z-index: -1;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.9);
        }
        #game-table-bg::before { content: ""; position: absolute; inset: 0; background: var(--table-overlay); }

        .scene { position: absolute; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10; }
        .scene.active { display: flex; }

        /* ==================== 3. UI COMPONENTS ==================== */
        /* Start Screen */
        #start-screen { background: rgba(0,0,0,0.85); z-index: 100; }
        .title-logo {
            font-size: 56px; color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px var(--neon-cyan), 0 0 40px var(--neon-pink);
            border: 4px solid #fff; padding: 10px 30px; border-radius: 10px; margin-bottom: 30px;
            box-shadow: 0 0 20px var(--neon-cyan), inset 0 0 20px var(--neon-cyan);
            background: rgba(0,0,0,0.6);
        }
        .menu-panel {
            background: rgba(46, 23, 15, 0.95); padding: 30px; width: 320px;
            border: 2px solid var(--vintage-gold); box-shadow: 0 0 30px rgba(0,0,0,0.8);
            text-align: center; display: flex; flex-direction: column; gap: 15px;
        }
        .input-group { text-align: left; }
        .styled-input {
            background: rgba(0,0,0,0.3); border: 1px solid #8d6e63; color: #fff;
            padding: 8px; width: 100%; box-sizing: border-box; text-align: center;
            font-size: 16px; margin-top: 5px; font-family: monospace;
        }

        /* Buttons */
        .main-btn {
            padding: 12px 0; font-size: 20px; background: var(--vintage-gold);
            border: 2px solid #fff; color: #2e1e19; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px var(--vintage-gold); width: 100%;
        }
        .main-btn.secondary { background: #2e1e19; border: 2px solid #8d6e63; color: #d7ccc8; box-shadow: none; font-size: 16px; }
        .game-btn { padding: 12px 24px; border-radius: 4px; font-weight: bold; font-size: 18px; border: 1px solid #ccc; border-bottom: 4px solid #999; cursor: pointer; }
        .btn-green { background: #4caf50; color: #fff; border-color: #1b5e20; }
        .btn-green:disabled { background: #555; cursor: not-allowed; }
        .btn-gray { background: #f5f5f5; color: #333; }
        .quit-btn { position: absolute; top: 15px; left: 15px; background: #2e1e19; border: 1px solid #5d4037; color: #ccc; padding: 6px 16px; z-index: 50; cursor: pointer; }
        
        /* Lobby */
        #lobby-screen { background: rgba(0,0,0,0.9); z-index: 90; }
        .pin-display { font-family: monospace; font-size: 48px; color: var(--neon-cyan); border: 2px dashed #555; padding: 10px; margin: 10px 0; letter-spacing: 5px; background: rgba(0,0,0,0.5); }
        .lobby-list { background: #222; min-height: 100px; border: 1px solid #444; padding: 10px; text-align: left; max-height: 200px; overflow-y: auto; }
        .lobby-item { padding: 5px; border-bottom: 1px solid #333; color: #ccc; font-size: 14px; }
        .choice-btn { width: 50px; height: 50px; border: 2px solid #555; background: #222; color: #aaa; font-size: 20px; cursor: pointer; margin: 0 5px; }
        .choice-btn.selected { background: var(--vintage-gold); color: #000; border-color: #fff; font-weight: bold; }
        .net-status { position: absolute; top: 15px; right: 15px; font-size: 12px; color: var(--neon-cyan); background: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: 4px; z-index: 50; display: none; border: 1px solid var(--neon-cyan); }

        /* Turn Notification - OPTIMIZED */
        #turn-notification {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            font-size: 32px; font-weight: bold; color: #fff;
            text-shadow: 0 0 10px #000, 0 0 20px var(--vintage-gold);
            background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 8px;
            border: 2px solid var(--vintage-gold); pointer-events: none; opacity: 0; z-index: 200;
            transition: opacity 0.3s; white-space: nowrap; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #turn-notification.show { opacity: 1; animation: pulseNotify 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes pulseNotify { 0% { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } 60% { transform: translate(-50%,-50%) scale(1.1); opacity: 1; } 100% { transform: translate(-50%,-50%) scale(1); } }

        /* Game Elements */
        .card { width: var(--card-width); height: var(--card-height); background: #fdfbf7; border-radius: var(--card-radius); box-shadow: var(--shadow-card); position: relative; border: 1px solid #c0b090; overflow: hidden; }
        .card.red { color: #b71c1c; } .card.black { color: #212121; }
        .card-inner { width: 100%; height: 100%; display: grid; grid-template-columns: 18px 1fr 18px; padding: 3px; box-sizing: border-box; }
        .corner { display: flex; flex-direction: column; align-items: center; font-size: 16px; line-height: 0.9; font-weight: bold; }
        .corner.bottom { transform: rotate(180deg); align-self: end; }
        .center-suit { display: flex; justify-content: center; align-items: center; font-size: 40px; opacity: 0.9; }
        
        .my-card { margin-left: -20px; cursor: pointer; transition: transform 0.2s; box-shadow: -2px 0 6px rgba(0,0,0,0.3); transform-origin: bottom center; }
        .my-card:first-child { margin-left: 0; }
        .my-card.selected { transform: translateY(-25px); border: 2px solid var(--vintage-gold); z-index: 100 !important; box-shadow: 0 0 15px var(--vintage-gold); background: #fff; }
        .desk-card { position: absolute; box-shadow: 1px 1px 5px rgba(0,0,0,0.4); }
        .flying-card { position: fixed; z-index: 9999; pointer-events: none; transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1); }

        #players-container { position: absolute; inset: 0; pointer-events: none; }
        .player-slot { position: absolute; width: 90px; display: flex; flex-direction: column; align-items: center; transition: all 0.5s; }
        .avatar { width: 54px; height: 54px; border-radius: 50%; background: #4e342e; border: 4px solid #3e2723; display: flex; justify-content: center; align-items: center; color: #d7ccc8; font-size: 24px; box-shadow: 0 5px 10px rgba(0,0,0,0.6); transition: transform 0.3s; position: relative; }
        .avatar.disconnected { filter: grayscale(100%); opacity: 0.5; border-color: #777; }
        .active-turn .avatar { border-color: var(--vintage-gold); box-shadow: 0 0 15px var(--vintage-gold); transform: scale(1.1); }
        .card-count-badge { position: absolute; top: 0; left: -5px; background: #b71c1c; color: white; width: 22px; height: 22px; border-radius: 50%; font-size: 12px; display: flex; justify-content: center; align-items: center; border: 2px solid #fff; z-index: 3; }
        .player-name-tag { background: rgba(0,0,0,0.7); color: #ddd; font-size: 12px; padding: 2px 6px; border-radius: 4px; margin-top: -8px; z-index: 3; border: 1px solid #555; white-space: nowrap; }
        .action-bubble { position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #fff; color: #000; padding: 5px 12px; border-radius: 15px; font-size: 14px; font-weight: bold; opacity: 0; transition: opacity 0.3s; z-index: 80; white-space: nowrap; border: 2px solid #000; }
        .action-bubble.show { opacity: 1; top: -50px; }

        /* Layout Slots */
        .slot-bottom { bottom: 20px; left: 20px; } .slot-bottom .played-cards-slot { bottom: 120px; left: 50%; transform: translateX(-50%); }
        .slot-right { top: 45%; right: 15px; transform: translateY(-50%); } .slot-right .played-cards-slot { right: 90px; top: 50%; transform: translateY(-50%); }
        .slot-left { top: 45%; left: 15px; transform: translateY(-50%); } .slot-left .played-cards-slot { left: 90px; top: 50%; transform: translateY(-50%); }
        .slot-top { top: 15px; left: 50%; transform: translateX(-50%); } .slot-top .played-cards-slot { top: 80px; left: 50%; transform: translateX(-50%); }
        .slot-top-left { top: 15px; left: 20%; } .slot-top-left .played-cards-slot { top: 70px; left: 50%; transform: translateX(-50%); }
        .slot-top-right { top: 15px; right: 20%; } .slot-top-right .played-cards-slot { top: 70px; left: 50%; transform: translateX(-50%); }
        .played-cards-slot { position: absolute; width: 100px; height: 90px; display: flex; justify-content: center; align-items: center; z-index: 10; }

        #center-table { position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); width: 250px; height: 160px; z-index: 5; background: radial-gradient(#1e8449, #145a32); border: 8px solid #2e1e19; border-radius: 80px; box-shadow: inset 0 0 20px #000; display: flex; justify-content: center; align-items: center; }
        #deck-pile { width: var(--card-width); height: var(--card-height); border-radius: var(--card-radius); background: repeating-linear-gradient(45deg, #283593 0px, #283593 5px, #fff 5px, #fff 6px); border: 3px solid #fff; display: flex; justify-content: center; align-items: center; box-shadow: -3px 3px 6px rgba(0,0,0,0.6); }
        #my-hand { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); display: flex; justify-content: center; height: 110px; width: auto; max-width: 90%; z-index: 30; }
        #player-controls { position: absolute; bottom: 30px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 50; opacity: 0.5; pointer-events: none; transition: opacity 0.3s; }
        #player-controls.active { opacity: 1; pointer-events: auto; }
        #scoreboard { position: absolute; top: 50px; right: 15px; background: #2e1e19; border: 4px solid #5d4037; border-radius: 4px; padding: 10px; z-index: 50; min-width: 130px; font-family: monospace; }
        #sb-header { text-align: center; font-size: 14px; color: var(--vintage-gold); font-weight: bold; margin-bottom: 5px; }
        .sb-row { display: flex; justify-content: space-between; color: #eee; font-size: 14px; margin-bottom: 2px; }

        /* Modal */
        #settlement-modal { background: rgba(0,0,0,0.9); z-index: 200; }
        .modal-content { background: #fdfbf7; color: #333; width: 90%; max-width: 450px; border: 8px solid #5d4037; border-radius: 2px; box-shadow: 0 0 50px #000; overflow: hidden; animation: popIn 0.3s; }
        .modal-header { background: #8d6e63; color: #fffde7; padding: 20px; text-align: center; font-size: 24px; font-weight: bold; border-bottom: 2px solid #5d4037; }
        .result-row { display: flex; justify-content: space-between; padding: 10px 15px; border-bottom: 1px dashed #bbb; font-size: 14px; font-family: monospace; }
        .result-row.winner { background: rgba(255, 215, 0, 0.2); font-weight: bold; }
        .gain.plus { color: #2e7d32; } .gain.minus { color: #c62828; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* Cassette */
        #cassette-btn { margin-top: 15px; padding: 8px 20px; background: #2e1e19; border: 2px solid #8d6e63; color: #d7ccc8; cursor: pointer; border-radius: 4px; font-family: monospace; width: 100%; box-sizing: border-box; }
        #cassette-modal { background: rgba(0,0,0,0.95); z-index: 300; }
        .cassette-panel { background: #2e1e19; color: #fff; width: 95%; max-width: 600px; border: 4px solid #5d4037; padding: 20px; border-radius: 10px; }
        .tape-row { display: flex; align-items: center; justify-content: space-between; background: #3e2723; padding: 10px; margin-bottom: 8px; border-radius: 4px; border: 1px solid #5d4037; }
        .rec-btn { background: #c62828; color: white; border: none; padding: 5px 10px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 30px; height: 30px; }
        .rec-btn.recording { animation: pulse 1s infinite; background: #ff0000; box-shadow: 0 0 10px red; }
        .take-chip { background: #444; padding: 2px 6px; border-radius: 4px; font-size: 10px; display: flex; gap: 4px; border: 1px solid #666; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        @media (max-width: 500px) {
            :root { --card-width: 50px; --card-height: 75px; }
            .card-inner { grid-template-columns: 14px 1fr 14px; } .corner { font-size: 12px; } .center-suit { font-size: 26px; }
            #my-hand { height: 90px; } .title-logo { font-size: 32px; padding: 5px 15px; }
            #center-table { width: 220px; height: 140px; top: 40%;} .slot-bottom .played-cards-slot { bottom: 100px; }
            #turn-notification { font-size: 24px; padding: 10px 20px; }
        }
    </style>
</head>
<body>

    <div id="game-table-bg"></div>

    <!-- Start Screen -->
    <div id="start-screen" class="scene active">
        <div class="title-logo">‰∏äÊµ∑Âπ≤Áû™Áúº</div>
        <div class="menu-panel">
            <div class="input-group">
                <label style="color:#aaa; font-size:14px;">‰Ω†ÁöÑÊòµÁß∞</label>
                <input type="text" id="nickname-input" class="styled-input" value="Player" maxlength="8">
            </div>
            <button class="main-btn" onclick="APP.startLocal()">ÂçïÊú∫ÁªÉ‰π†</button>
            <div style="margin: 10px 0; border-top: 1px solid #555; padding-top: 15px;">
                <div style="font-size:14px; color:#aaa; margin-bottom:10px;">ÁΩëÁªúÂØπÊàò</div>
                <button class="main-btn secondary" onclick="UI.showLobby('host')">ÂàõÂª∫ÊàøÈó¥</button>
                <button class="main-btn secondary" onclick="UI.showLobby('join')">Âä†ÂÖ•ÊàøÈó¥</button>
            </div>
            <button id="cassette-btn" onclick="AUDIO.Recorder.openUI()">üéôÔ∏è Á£ÅÂ∏¶ÂΩïÈü≥ÂÆ§</button>
            <div style="font-size: 12px; color: #8d6e63; margin-top: 10px; opacity: 0.8;">Powered by RexÁà∏Áà∏ & PeerJS</div>
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="scene">
        <div class="menu-panel" style="width: 400px;">
            <div id="lobby-title" style="font-size: 24px; color: #fff; margin-bottom: 10px;">ÂáÜÂ§áÊàøÈó¥</div>
            <div id="host-ui" style="display:none;">
                <div style="color:#aaa; font-size:14px;">ÊàøÈó¥ PIN Á†Å</div>
                <div class="pin-display" id="my-pin">....</div>
                <div class="lobby-list" id="host-player-list">Á≠âÂæÖÁé©ÂÆ∂...</div>
                <div style="font-size:16px; color:#aaa; margin-bottom:10px;">ÊÄª‰∫∫Êï∞ (‰∏çË∂≥AIË°•)</div>
                <div style="display:flex; justify-content:center; margin-bottom:20px;">
                    <button class="choice-btn selected" onclick="UI.selectPlayerCount(3, this)">3</button>
                    <button class="choice-btn" onclick="UI.selectPlayerCount(4, this)">4</button>
                    <button class="choice-btn" onclick="UI.selectPlayerCount(5, this)">5</button>
                    <button class="choice-btn" onclick="UI.selectPlayerCount(6, this)">6</button>
                </div>
                <button class="main-btn" onclick="APP.launchNetworkGame()">ÂºÄÂßãÊ∏∏Êàè</button>
            </div>
            <div id="client-ui" style="display:none;">
                <input type="tel" id="join-pin" placeholder="ËæìÂÖ• 4 ‰Ωç PIN" maxlength="4" style="background:#333; color:#fff; border:2px solid #555; font-size:24px; padding:10px; width:150px; text-align:center; margin-bottom:20px; letter-spacing:5px;">
                <br>
                <button class="main-btn" onclick="APP.joinGame()">ËøûÊé•</button>
                <div id="join-status" style="margin-top:10px; color:#ccc;"></div>
            </div>
            <button class="quit-btn" style="position:relative; top:auto; left:auto; margin-top:10px;" onclick="location.reload()">ËøîÂõû</button>
        </div>
    </div>

    <!-- Game Scene -->
    <div id="game-scene" class="scene">
        <div id="turn-notification">ËΩÆÂà∞‰Ω†‰∫Ü</div>
        <div id="game-ui" style="width:100%; height:100%;">
            <button class="quit-btn" onclick="APP.quit()">ÈÄÄÂá∫</button>
            <div class="net-status" id="net-indicator">‚óè ONLINE</div>
            <div id="scoreboard"><div id="sb-header">ËÆ∞ÂàÜÊùø</div><div id="sb-content"></div></div>
            <div id="players-container"></div>
            <div id="center-table"><div id="deck-pile"><span id="deck-count" style="color:#fff; font-weight:bold; font-size:20px; text-shadow: 1px 1px 0 #000;">54</span></div></div>
            <div id="player-controls">
                <button class="game-btn btn-gray" id="btn-pass" onclick="APP.humanPass()">‰∏çË¶Å</button>
                <button class="game-btn btn-green" id="btn-play" onclick="APP.humanPlay()" disabled>Âá∫Áâå</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="settlement-modal" class="scene">
        <div class="modal-content">
            <div class="modal-header">Êú¨Â±ÄÁªìÊùü</div><div id="settle-list"></div>
            <div style="padding: 20px; text-align: center;">
                <button class="main-btn" id="next-round-btn" style="font-size:18px; padding: 10px 40px;" onclick="APP.nextRound()">‰∏ã‰∏ÄÂ±Ä</button>
                <div id="wait-host-msg" style="display:none; color:#666;">Á≠âÂæÖÊàø‰∏ªÂºÄÂßã...</div>
            </div>
        </div>
    </div>

    <div id="cassette-modal" class="scene">
        <div class="cassette-panel">
            <div style="text-align:center; font-size:20px; color:var(--vintage-gold); margin-bottom:20px; border-bottom:1px solid #555;"> Tape Recorder</div>
            <div id="tape-list"></div>
            <div style="text-align:center; margin-top:20px;"><button class="main-btn" style="font-size:16px;" onclick="AUDIO.Recorder.closeUI()">Save & Close</button></div>
        </div>
    </div>

<script>
    /* ==========================================================================
       1. CONFIGURATION & CONSTANTS
       ========================================================================== */
    const CONFIG = {
        SUITS: ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'], RANKS: ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'],
        VALS: { '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14, '2':15, 'S':16, 'B':17 },
        NPC_NAMES: ["ÁéãÈòøÂß®", "ÊùéÁßëÈïø", "ËÄÅÂÖãÂãí", "Â∞èÈôà", "Âº†Â§ßÁà∑", "ÂºÑÂ†Ç‰∏ÄÊûùËä±", "ÈöîÂ£ÅËÄÅÁéã"],
        LAYOUTS: { 3: ['slot-bottom', 'slot-right', 'slot-left'], 4: ['slot-bottom', 'slot-right', 'slot-top', 'slot-left'], 5: ['slot-bottom', 'slot-right', 'slot-top-right', 'slot-top-left', 'slot-left'], 6: ['slot-bottom', 'slot-right', 'slot-top-right', 'slot-top', 'slot-top-left', 'slot-left'] },
        QUOTES: { PASS: ["‰∏çË¶Å", "Ëøá", "Ë¶Å‰∏çËµ∑", "Pass"], WIN: ["Ëµ¢‰∫ÜÔºÅ", "ËøòÊúâË∞ÅÔºü", "ÊâøËÆ©", "ÁªìÊùüÊàòÊñó"], START: ["ÂèëÁâå‰∫Ü", "ÁúãÁâå", "ÂêÑÂá≠Êú¨‰∫ã"] },
        
        // === Network Expert: Stable Global Architecture ===
        PEER_CONFIG: { 
            host: '0.peerjs.com', 
            port: 443, 
            secure: true, 
            pingInterval: 5000, 
            debug: 1, 
            config: { 
                iceServers: [ 
                    { urls: "stun:openrelay.metered.ca:80" },
                    { urls: "turn:openrelay.metered.ca:80", username: "e4b469df87f075fa140a04a8", credential: "V141Y4bT8Fgomte0" },
                    { urls: "turn:openrelay.metered.ca:443", username: "e4b469df87f075fa140a04a8", credential: "V141Y4bT8Fgomte0" }
                ] 
            } 
        },
        APP_PREFIX: 'gandengyan-fin-'
    };

    /* ==========================================================================
       2. NETWORK MODULE (NET) - Âü∫‰∫é PeerJS
       ========================================================================== */
    const NET = {
        peer: null, mode: 'offline', hostConn: null, clients: [], myPin: null,
        
        initHost: function(cb) {
            this.mode = 'host'; this.clients = []; this.myPin = Math.floor(1000 + Math.random() * 9000).toString();
            if(this.peer) this.peer.destroy(); 
            this.peer = new Peer(CONFIG.APP_PREFIX + this.myPin, CONFIG.PEER_CONFIG);
            
            // --- Timeout & ID Handlers ---
            let opened = false;
            let idTimeout = setTimeout(() => {
                if (!opened) {
                    console.log("[WebRTC] Host timeout, forcing reconnect...");
                    this.peer.reconnect();
                }
            }, 5000);

            this.peer.on('open', () => { 
                opened = true; clearTimeout(idTimeout); cb(this.myPin); 
            });

            this.peer.on('connection', (conn) => {
                conn.on('open', () => { conn.send({type:'WELCOME'}); });
                conn.on('data', (data) => {
                    if(data.type === 'JOIN') { 
                        // === Advanced ICU Reconnection Logic ===
                        let existingClient = this.clients.find(c => c.name === data.name);
                        let existingPlayerState = STATE.players.find(p => p.name === data.name);

                        if (existingClient || (STATE.players.length > 0 && existingPlayerState)) {
                            console.log(`[Host] CPR - Reconnecting player: ${data.name}`);
                            
                            // 1. Update existing client socket reference
                            if (existingClient) {
                                existingClient.conn = conn;
                                existingClient.id = conn.peer;
                            } else {
                                this.clients.push({ conn: conn, id: conn.peer, name: data.name });
                            }

                            // 2. Re-bind Game State
                            if (existingPlayerState) {
                                existingPlayerState.peerId = conn.peer;
                                existingPlayerState.disconnected = false;
                                existingPlayerState.isCpu = false;
                            }

                            // 3. IMMEDIATE SYNC (The CPR Kit)
                            // Tell client who they are
                            conn.send({ type: 'GAME_START', players: STATE.players, playerCount: STATE.playerCount });
                            // Inject current game state
                            conn.send({ type: 'STATE', state: STATE, reason: 'RECONNECT' });
                            
                            APP.syncState('RECONNECT_NOTIFY');
                            UI.updateLobbyList();
                        } else {
                            // Normal New Player Join
                            if (STATE.players.length > 0) {
                                conn.send({ type: 'ERROR', msg: 'Game running' });
                                setTimeout(() => conn.close(), 500);
                            } else {
                                this.clients.push({ conn: conn, id: conn.peer, name: data.name });
                                UI.updateLobbyList();
                            }
                        }
                    }
                    else APP.onNetworkData(data, conn);
                });
                conn.on('close', () => { 
                    if(STATE.players.length > 0) {
                        let clientObj = this.clients.find(c => c.conn === conn);
                        if (clientObj) {
                            let p = STATE.players.find(pl => pl.name === clientObj.name);
                            if (p) { p.disconnected = true; APP.syncState('DISCONNECT'); }
                        }
                    } else {
                        this.clients = this.clients.filter(c => c.conn !== conn); 
                        UI.updateLobbyList(); 
                    }
                });
            });
            this.peer.on('error', (err) => { if(err.type === 'unavailable-id') setTimeout(() => this.initHost(cb), 500); });
        },

        joinRoom: function(pin, name, cbSuccess, cbErr) {
            this.mode = 'client'; if(this.peer) this.peer.destroy(); 
            this.peer = new Peer(CONFIG.PEER_CONFIG);

            let opened = false;
            let idTimeout = setTimeout(() => {
                if (!opened) {
                    console.log("[WebRTC] Client timeout, forcing reconnect...");
                    this.peer.reconnect();
                }
            }, 5000);

            this.peer.on('open', () => {
                opened = true; clearTimeout(idTimeout);
                this.hostConn = this.peer.connect(CONFIG.APP_PREFIX + pin, { reliable: true });
                this.hostConn.on('open', () => { this.hostConn.send({ type: 'JOIN', name: name }); cbSuccess(); });
                this.hostConn.on('data', (data) => APP.onNetworkData(data));
                this.hostConn.on('close', () => { location.reload(); });
            });
            this.peer.on('error', cbErr);
        },
        broadcast: function(data) { if(this.mode !== 'host') return; this.clients.forEach(c => { if(c.conn.open) c.conn.send(data); }); },
        sendToHost: function(data) { if(this.mode === 'client' && this.hostConn && this.hostConn.open) this.hostConn.send(data); }
    };

    /* ==========================================================================
       3. GAME STATE
       ========================================================================== */
    const STATE = { players: [], deck: [], currTurn: 0, lastPlay: null, passCount: 0, playerCount: 3, selectedIndices: [], bombCount: 0 };

    /* ==========================================================================
       4. AUDIO SYSTEM 
       ========================================================================== */
    const AUDIO = {
        ctx: null, init: function() { window.AudioContext = window.AudioContext||window.webkitAudioContext; this.ctx = new AudioContext(); },
        play: function(type) { if(this.Recorder.playRandom(type)) return; this.playSynth(type); },
        playSynth: function(type) {
            if(!this.ctx) return; const t=this.ctx.currentTime, o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.connect(g); g.connect(this.ctx.destination);
            if(type==='play') { o.frequency.setValueAtTime(600,t); o.frequency.exponentialRampToValueAtTime(100,t+0.1); g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.1); o.start(t); o.stop(t+0.1); }
            else if(type==='win') { [523,659,783].forEach((f,i)=>{let x=this.ctx.createOscillator(),y=this.ctx.createGain();x.connect(y);y.connect(this.ctx.destination);x.frequency.value=f;y.gain.setValueAtTime(0.1,t+i*0.1);y.gain.linearRampToValueAtTime(0,t+i*0.1+0.5);x.start(t+i*0.1);x.stop(t+i*0.1+0.5);}); }
            else { o.type='square'; o.frequency.value=150; g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.2); o.start(t); o.stop(t+0.2); }
        },
        Recorder: {
            sounds: {'play':[],'pass':[],'bomb':[],'win':[],'alert':[],'chain_bomb':[],'iron_tree':[],'suffocated':[]}, labels: {'play':'Play','pass':'Pass','bomb':'Bomb','win':'Win','alert':'Error','chain_bomb':'Chain Bomb','iron_tree':'Iron Tree','suffocated':'Suffocated'},
            openUI: function() { document.getElementById('cassette-modal').classList.add('active'); this.renderUI(); },
            closeUI: function() { document.getElementById('cassette-modal').classList.remove('active'); },
            renderUI: function() { let c=document.getElementById('tape-list'); c.innerHTML=''; for(let k in this.sounds) c.innerHTML+=`<div class="tape-row"><div class="tape-label">${this.labels[k]}</div><div class="tape-controls"><div class="takes-list" id="takes-${k}"></div><button class="rec-btn" onmousedown="AUDIO.Recorder.start('${k}',this)" onmouseup="AUDIO.Recorder.stop(this)">‚óè</button></div></div>`; this.refreshTakes(); },
            refreshTakes: function() { for(let k in this.sounds) { let d=document.getElementById(`takes-${k}`); if(d) { d.innerHTML=''; this.sounds[k].forEach((_,i)=>d.innerHTML+=`<div class="take-chip">T${i+1}<span style="cursor:pointer;color:#81c784" onclick="AUDIO.Recorder.prev('${k}',${i})">‚ñ∂</span><span style="cursor:pointer;color:#e57373" onclick="AUDIO.Recorder.del('${k}',${i})">√ó</span></div>`); } } },
            start: function(k,b) { navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{this.m=new MediaRecorder(s);this.c=[];this.m.ondataavailable=e=>this.c.push(e.data);this.m.onstop=()=>{this.sounds[k].push(URL.createObjectURL(new Blob(this.c)));this.refreshTakes();};this.m.start();b.classList.add('recording');}); },
            stop: function(b) { if(this.m&&this.m.state==='recording'){this.m.stop();b.classList.remove('recording');} },
            del: function(k,i) { this.sounds[k].splice(i,1); this.refreshTakes(); }, prev: function(k,i) { new Audio(this.sounds[k][i]).play(); },
            playRandom: function(k) { if(this.sounds[k].length) { new Audio(this.sounds[k][Math.floor(Math.random()*this.sounds[k].length)]).play(); return true; } return false; }
        }
    };

    /* ==========================================================================
       5. CORE RULES ENGINE
       ========================================================================== */
    const RULES = {
        analyze: function(c) {
            if(!c||!c.length)return null; c.sort((a,b)=>a.val-b.val); let len=c.length, j=c.filter(x=>x.isJoker).length, n=c.filter(x=>!x.isJoker);
            if(len===1&&c[0].isJoker) return null; if(len===2&&j===2) return {type:'rocket',val:99,count:2};
            if(len===1) return {type:'single',val:c[0].val,count:1};
            if(len===2) { if(j===0&&c[0].val===c[1].val) return {type:'pair',val:c[0].val,count:2}; if(j===1) return {type:'pair',val:n[0].val,count:2}; }
            if(len>=3&&n.every(x=>x.val===n[0].val)) return {type:'bomb',val:n[0].val,count:len};
            if(!c.some(x=>x.val===15)) {
                let s=new Set(); n.forEach(x=>s.add(x.val));
                if(s.size===n.length && (n[n.length-1].val-n[0].val+1)-n.length<=j) return {type:'straight',val:n[0].val,count:len};
                let cnt={}; n.forEach(x=>cnt[x.val]=(cnt[x.val]||0)+1); let vals=Object.keys(cnt).map(Number).sort((a,b)=>a-b);
                if(!vals.some(v=>cnt[v]>2)) { let need=0; vals.forEach(v=>{if(cnt[v]===1)need++}); for(let i=vals[0];i<=vals[vals.length-1];i++)if(!cnt[i])need+=2; if(need<=j&&(j-need)%2===0) return {type:'consec_pairs',val:n[0].val,count:len}; }
            }
            return null;
        },
        canBeat: function(my, table) {
            if(!my)return false; if(!table)return true; if(my.type==='rocket')return true; if(table.type==='rocket')return false;
            if(my.type==='bomb') { if(table.type!=='bomb')return true; return my.count>table.count || (my.count===table.count && my.val>table.val); }
            if(table.type==='bomb')return false;
            if(my.type===table.type && my.count===table.count) {
                if((my.type==='single'||my.type==='pair') && my.val===15 && table.val===15) return false;
                if((my.type==='single'||my.type==='pair') && my.val===15) return true;
                return my.val===table.val+1;
            } return false;
        }
    };

    /* ==========================================================================
       6. AI & UI
       ========================================================================== */
    const AI = {
        move: function(player) {
            let hand=[...player.hand], last=STATE.lastPlay, move=null, groups=APP.groupHand(hand);
            if(!last) { move = groups.straights[0] || groups.consecPairs[0] || groups.pairs.find(p=>p.val<15) || groups.pairs[0] || groups.singles.find(s=>s.val<15) || groups.singles[0] || groups.bombs[0] || groups.rockets[0]; }
            else {
                let pool = {'straight':groups.straights,'consec_pairs':groups.consecPairs,'pair':groups.pairs,'single':groups.singles}[last.type] || [];
                let cands = [...pool.filter(m=>RULES.canBeat(m,last)), ...groups.bombs, ...groups.rockets];
                if(cands.length) {
                    cands.sort((a,b)=>(a.val+(a.type.includes('bomb')?100:0)) - (b.val+(b.type.includes('bomb')?100:0)));
                    let best = cands[0], oppCards = STATE.players[last.ownerIdx].hand.length;
                    if((best.val===15||best.type.includes('bomb')||best.type==='rocket') && last.val<10 && !last.type.includes('bomb') && oppCards>4) move=null; else move=best;
                }
            }
            if(move) { let idxs=move.idxs; idxs.sort((a,b)=>b-a).forEach(i=>player.hand.splice(i,1)); APP.turnEnd('play', idxs.map(i=>hand[i])); } else APP.turnEnd('pass');
        }
    };

    const UI = {
        selectPlayerCount: function(n, btn) { document.querySelectorAll('.choice-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); STATE.playerCount = n; },
        showLobby: function(mode) {
            document.getElementById('start-screen').classList.remove('active'); document.getElementById('lobby-screen').classList.add('active');
            if(mode==='host') { document.getElementById('host-ui').style.display='block'; document.getElementById('client-ui').style.display='none'; APP.startHosting(); }
            else { document.getElementById('host-ui').style.display='none'; document.getElementById('client-ui').style.display='block'; }
        },
        updateLobbyList: function() { 
            let myName = document.getElementById('nickname-input').value || "Êàø‰∏ª";
            if(NET.mode==='host') document.getElementById('host-player-list').innerHTML = `<div class="lobby-item">1. ${myName}</div>` + NET.clients.map((c,i)=>`<div class="lobby-item">${i+2}. ${c.name||'Áé©ÂÆ∂'}</div>`).join(''); 
        },
        renderLayout: function() {
            let container = document.getElementById('players-container'); container.innerHTML = '';
            let config = CONFIG.LAYOUTS[STATE.playerCount], myIdx = APP.myPlayerIdx;
            STATE.players.forEach((p, i) => {
                let posClass = config[(i - myIdx + STATE.playerCount) % STATE.playerCount];
                let avatarClass = `avatar ${p.disconnected ? 'disconnected' : ''}`;
                let nameSuffix = p.disconnected ? ' (Êñ≠Á∫ø)' : '';
                container.innerHTML += `<div class="player-slot ${posClass}" id="p-slot-${i}"><div class="action-bubble" id="bubble-${i}"></div><div class="avatar-wrapper"><div class="card-count-badge" id="badge-count-${i}">${p.hand.length}</div><div class="${avatarClass}">${i===myIdx?'Êàë':(p.isCpu?'ü§ñ':'üë§')}</div></div><div class="player-name-tag">${p.name}${nameSuffix}</div><div class="played-cards-slot"></div></div>`;
            });
            if(!document.getElementById('my-hand')) document.getElementById('player-controls').parentNode.insertBefore(document.createElement('div'), document.getElementById('player-controls')).id = 'my-hand';
            if(STATE.lastPlay && STATE.lastPlay.cards && STATE.lastPlay.ownerIdx !== undefined) {
                this.renderPlayedCards(STATE.lastPlay.ownerIdx, STATE.lastPlay.cards);
            }
        },
        renderHand: function() {
            let container = document.getElementById('my-hand'); container.innerHTML = '';
            STATE.players[APP.myPlayerIdx].hand.forEach((card, idx) => {
                let el = document.createElement('div'); el.className = `card ${card.color} my-card ${STATE.selectedIndices.includes(idx)?'selected':''}`;
                let r=card.rank, s=card.suit; if(card.isJoker) r='J\nO\nK\nE\nR';
                el.innerHTML = card.isJoker ? `<div class="card-inner"><div class="corner">${r}</div><div class="center-suit">${s}</div><div class="corner bottom">${r}</div></div>` : `<div class="card-inner"><div class="corner"><span>${r}</span><span class="suit">${s}</span></div><div class="center-suit">${s}</div><div class="corner bottom"><span>${r}</span><span class="suit">${s}</span></div></div>`;
                el.onclick = () => { let p=STATE.selectedIndices.indexOf(idx); if(p>=0)STATE.selectedIndices.splice(p,1); else STATE.selectedIndices.push(idx); UI.renderHand(); APP.checkHumanButtons(); };
                container.appendChild(el);
            });
        },
        renderPlayedCards: function(pIdx, cards) {
            let slot = document.querySelector(`#p-slot-${pIdx} .played-cards-slot`); if(slot) { slot.innerHTML = ''; cards.forEach((c, i) => {
                let el = document.createElement('div'); el.className = `card ${c.color} desk-card`;
                let r=c.rank, s=c.suit; if(c.isJoker) r='J\nO\nK\nE\nR';
                el.innerHTML = c.isJoker ? `<div class="card-inner"><div class="corner">${r}</div><div class="center-suit">${s}</div><div class="corner bottom">${r}</div></div>` : `<div class="card-inner"><div class="corner"><span>${r}</span><span class="suit">${s}</span></div><div class="center-suit">${s}</div><div class="corner bottom"><span>${r}</span><span class="suit">${s}</span></div></div>`;
                el.style.transform = `rotate(${(i-cards.length/2)*5}deg) translateX(${i*15}px) scale(0.9)`; slot.appendChild(el);
            }); }
        },
        showBubble: function(pIdx, text) { let b = document.getElementById(`bubble-${pIdx}`); if(b) { b.innerText = text; b.classList.add('show'); setTimeout(()=>b.classList.remove('show'), 1200); } },
        showTurnNotify: function(pIdx) {
            let isMe = (pIdx === APP.myPlayerIdx);
            let el = document.getElementById('turn-notification');
            el.innerText = isMe ? "ËΩÆÂà∞‰Ω†‰∫Ü" : `ËΩÆÂà∞ ${STATE.players[pIdx].name}`;
            el.style.color = isMe ? "#00fff2" : "#fff"; 
            el.style.borderColor = isMe ? "#00fff2" : "#d4af37";
            el.style.textShadow = isMe ? "0 0 20px #00fff2" : "0 0 10px #000";
            el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 1500);
            document.querySelectorAll('.player-slot').forEach(e => e.classList.remove('active-turn')); 
            let active = document.getElementById(`p-slot-${pIdx}`); if(active) active.classList.add('active-turn');
        },
        updateInfo: function() {
            document.getElementById('deck-count').innerText = STATE.deck.length;
            STATE.players.forEach((p, i) => { let b = document.getElementById(`badge-count-${i}`); if(b) b.innerText = p.hand.length; });
            document.getElementById('sb-content').innerHTML = STATE.players.map(p => `<div class="sb-row"><span>${p.name}</span><span class="sb-chips">${p.chips}</span></div>`).join('');
            let headerText = "ËÆ∞ÂàÜÊùø"; if(NET.mode !== 'offline' && NET.myPin) headerText = `${NET.myPin} ÂåÖÊàø`;
            let sbHeader = document.querySelector('#sb-header'); if(sbHeader) sbHeader.innerText = headerText;
        },
        animThrow: function(pIdx, cards, cb) {
            let start = (pIdx === APP.myPlayerIdx) ? document.getElementById('my-hand') : document.getElementById(`p-slot-${pIdx}`), end = document.querySelector(`#p-slot-${pIdx} .played-cards-slot`);
            if(!start||!end) { if(cb)cb(); return; }
            let sR=start.getBoundingClientRect(), eR=end.getBoundingClientRect(), fly=document.createElement('div');
            fly.className='flying-card'; fly.style.left=(sR.left+sR.width/2)+'px'; fly.style.top=(sR.top+sR.height/2)+'px';
            cards.forEach((c,i)=>{ let el=document.createElement('div'); el.className=`card ${c.color}`; el.style.position='absolute'; el.style.left=(i*15)+'px'; fly.appendChild(el); });
            document.body.appendChild(fly);
            requestAnimationFrame(()=>{ fly.style.left=(eR.left+eR.width/2)+'px'; fly.style.top=(eR.top+eR.height/2)+'px'; fly.style.transform='scale(0.9)'; });
            setTimeout(()=>{ fly.remove(); if(cb)cb(); }, 500);
        },
        animSweep: function(cb) {
            let cards=document.querySelectorAll('.played-cards-slot .desk-card'); if(!cards.length){if(cb)cb();return;}
            let cx=window.innerWidth/2, cy=window.innerHeight/2;
            cards.forEach(c=>{ let r=c.getBoundingClientRect(); c.style.position='fixed'; c.style.left=r.left+'px'; c.style.top=r.top+'px'; c.style.transition='all 0.6s ease-in'; requestAnimationFrame(()=>{c.style.left=cx+'px'; c.style.top=cy+'px'; c.style.opacity=0; c.style.transform='scale(0.2)';}); });
            setTimeout(()=>{document.querySelectorAll('.played-cards-slot').forEach(e=>e.innerHTML='');if(cb)cb();},600);
        }
    };

    /* ==========================================================================
       7. MAIN APP CONTROLLER
       ========================================================================== */
    const APP = {
        myPlayerIdx: 0,
        startLocal: function() { NET.mode = 'offline'; this.myPlayerIdx = 0; this.launchGame(STATE.playerCount); },
        startHosting: function() { NET.initHost((pin) => document.getElementById('my-pin').innerText = pin); },
        joinGame: function() {
            let pin = document.getElementById('join-pin').value; if(pin.length!==4) return alert("PIN?");
            let name = document.getElementById('nickname-input').value || "Player";
            document.getElementById('join-status').innerText = "ËøûÊé•‰∏≠...";
            NET.joinRoom(pin, name, () => { document.getElementById('join-status').innerText = "Â∑≤ËøûÊé•! Á≠âÂæÖÊàø‰∏ª..."; document.getElementById('net-indicator').style.display='block'; }, () => document.getElementById('join-status').innerText = "Â§±Ë¥•");
        },
        launchNetworkGame: function() {
            if(NET.mode !== 'host') return;
            let myName = document.getElementById('nickname-input').value || "Êàø‰∏ª";
            let players = [{id:0,name:myName,isCpu:false,hand:[],chips:200}];
            NET.clients.forEach((c,i) => players.push({id:i+1,name:c.name,isCpu:false,hand:[],chips:200,peerId:c.id}));
            for(let i=1+NET.clients.length; i<STATE.playerCount; i++) players.push({id:i,name:CONFIG.NPC_NAMES[i-1]||`AI-${i}`,isCpu:true,hand:[],chips:200});
            STATE.players = players; NET.broadcast({ type: 'GAME_START', players: players, playerCount: STATE.playerCount }); this.start();
        },
        start: function() {
            AUDIO.init(); document.getElementById('start-screen').classList.remove('active'); document.getElementById('lobby-screen').classList.remove('active'); document.getElementById('game-scene').classList.add('active');
            if(NET.mode !== 'offline') document.getElementById('net-indicator').style.display = 'block';
            if(NET.mode === 'client') UI.renderLayout(); else this.resetRound();
        },
        launchGame: function(count) {
            STATE.players=[]; let names=[...CONFIG.NPC_NAMES].sort(()=>Math.random()-0.5); let myName = document.getElementById('nickname-input').value || "Êàë";
            for(let i=0; i<count; i++) STATE.players.push({id:i,name:i===0?myName:names[i-1],isCpu:i!==0,hand:[],chips:200});
            this.start();
        },
        resetRound: function() {
            STATE.lastPlay=null; STATE.passCount=0; STATE.selectedIndices=[]; STATE.bombCount=0;
            document.getElementById('settlement-modal').classList.remove('active');
            STATE.deck=[]; CONFIG.RANKS.forEach(r=>CONFIG.SUITS.forEach(s=>STATE.deck.push({suit:s,rank:r,val:CONFIG.VALS[r],color:['‚ô•','‚ô¶'].includes(s)?'red':'black',isJoker:false})));
            STATE.deck.push({suit:'ü§°',rank:'JOKER',val:16,color:'black',isJoker:true},{suit:'üë∫',rank:'JOKER',val:17,color:'red',isJoker:true});
            for(let i=STATE.deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[STATE.deck[i],STATE.deck[j]]=[STATE.deck[j],STATE.deck[i]];}
            STATE.players.forEach(p=>p.hand=[]); for(let i=0;i<5;i++)STATE.players.forEach(p=>{if(STATE.deck.length)p.hand.push(STATE.deck.pop())});
            STATE.players.forEach(p=>p.hand.sort((a,b)=>(a.val-b.val)||(CONFIG.SUITS.indexOf(a.suit)-CONFIG.SUITS.indexOf(b.suit))));
            STATE.currTurn = Math.floor(Math.random()*STATE.playerCount);
            if(STATE.deck.length > 0) { let dealer = STATE.players[STATE.currTurn]; dealer.hand.push(STATE.deck.pop()); dealer.hand.sort((a,b)=>(a.val-b.val)||(CONFIG.SUITS.indexOf(a.suit)-CONFIG.SUITS.indexOf(b.suit))); }
            this.syncState('RESET_ROUND'); UI.showBubble(STATE.currTurn, "ÂèëÁâå‰∫Ü"); this.processTurn();
        },
        processTurn: function() {
            UI.updateInfo(); let player = STATE.players[STATE.currTurn];
            if(STATE.passCount >= STATE.playerCount - 1 && STATE.lastPlay) {
                if(NET.mode==='host') NET.broadcast({type:'EVENT',name:'SWEEP',pIdx:STATE.currTurn});
                UI.showBubble(STATE.currTurn, "Ëµ¢‰∫ÜÔºÅ");
                UI.animSweep(()=>{ this.drawCard(STATE.currTurn); STATE.lastPlay=null; STATE.passCount=0; this.syncState(); if(player.hand.length>0)this.continueTurn(player); });
                return;
            }
            this.continueTurn(player);
        },
        continueTurn: function(player) {
            this.syncState();
            if(player.isCpu) { document.getElementById('player-controls').classList.remove('active'); if(NET.mode!=='client') setTimeout(()=>AI.move(player), 1000+Math.random()*500); }
            else if(player.id === this.myPlayerIdx) { document.getElementById('player-controls').classList.add('active'); this.checkHumanButtons(); }
            else { document.getElementById('player-controls').classList.remove('active'); }
        },
        humanPlay: function() {
            let cards = STATE.selectedIndices.map(i=>STATE.players[this.myPlayerIdx].hand[i]);
            if(cards.length===1&&cards[0].isJoker) { AUDIO.play('alert'); UI.showBubble(this.myPlayerIdx, "No Solo Joker!"); return; }
            if(!RULES.analyze(cards)) { AUDIO.play('alert'); return; }
            if(NET.mode==='client') { NET.sendToHost({type:'ACTION',action:'play',cards:cards}); STATE.selectedIndices=[]; document.getElementById('player-controls').classList.remove('active'); }
            else this.turnEnd('play', cards);
        },
        humanPass: function() {
            if(NET.mode==='client') { NET.sendToHost({type:'ACTION',action:'pass'}); document.getElementById('player-controls').classList.remove('active'); }
            else this.turnEnd('pass');
        },
        nextRound: function() { this.resetRound(); },
        turnEnd: function(action, cards) {
            let pIdx = STATE.currTurn, player = STATE.players[pIdx];
            if(action === 'play') {
                let analysis = RULES.analyze(cards);
                STATE.lastPlay=analysis; STATE.lastPlay.ownerIdx=pIdx; STATE.lastPlay.cards=cards;
                STATE.passCount=0;
                if(analysis.type.includes('bomb')||analysis.type==='rocket') STATE.bombCount++;
                let snd = (analysis.type.includes('bomb')||analysis.type==='rocket') ? 'bomb' : 'play';
                if(player.hand.length===0 && cards.some(c=>c.val===3)) snd = 'iron_tree';
                if(NET.mode==='host') NET.broadcast({type:'EVENT',name:'THROW',pIdx:pIdx,cards:cards,sound:snd});
                AUDIO.play(snd);
                if(pIdx===this.myPlayerIdx) { STATE.selectedIndices.sort((a,b)=>b-a).forEach(i=>player.hand.splice(i,1)); STATE.selectedIndices=[]; }
                else { cards.forEach(c=>{ let idx=player.hand.findIndex(h=>h.val===c.val&&h.suit===c.suit); if(idx>-1)player.hand.splice(idx,1); }); }
                UI.renderHand();
                UI.animThrow(pIdx, cards, () => { UI.renderPlayedCards(pIdx, cards); if(player.hand.length===0) setTimeout(()=>this.settle(pIdx),500); else this.nextTurn(); });
            } else {
                STATE.passCount++; if(NET.mode==='host') NET.broadcast({type:'EVENT',name:'PASS',pIdx:pIdx});
                AUDIO.play('pass'); UI.showBubble(pIdx, "‰∏çË¶Å"); this.nextTurn();
            }
        },
        nextTurn: function() { STATE.currTurn=(STATE.currTurn+1)%STATE.playerCount; if(NET.mode!=='client') this.processTurn(); },
        drawCard: function(pIdx) { if(STATE.deck.length>0) { STATE.players[pIdx].hand.push(STATE.deck.pop()); STATE.players[pIdx].hand.sort((a,b)=>(a.val-b.val)||(CONFIG.SUITS.indexOf(a.suit)-CONFIG.SUITS.indexOf(b.suit))); } else UI.showBubble(pIdx,"Empty Deck"); },
        checkHumanButtons: function() {
            let play=document.getElementById('btn-play'), pass=document.getElementById('btn-pass'); pass.disabled=(STATE.lastPlay===null);
            if(STATE.selectedIndices.length===0) { play.disabled=true; return; }
            let cards=STATE.selectedIndices.map(i=>STATE.players[this.myPlayerIdx].hand[i]), analysis=RULES.analyze(cards);
            play.disabled = !(analysis && RULES.canBeat(analysis, STATE.lastPlay));
        },
        settle: function(wIdx) {
            AUDIO.play('win'); let list=document.getElementById('settle-list'); list.innerHTML=''; let pot=0, mult=Math.pow(2,STATE.bombCount);
            document.querySelector('.modal-header').innerText=`Êú¨Â±ÄÁªìÊùü (ÂÄçÊï∞ x${mult})`;
            STATE.players.forEach((p,i)=>{
                let isWin=(i===wIdx), cost=0, badges="", dMult="";
                if(!isWin) {
                    let bad=p.hand.filter(c=>c.val===15||c.isJoker).length, hBombs=0, cnt={};
                    p.hand.forEach(c=>cnt[c.val]=(cnt[c.val]||0)+1); for(let v in cnt)if(cnt[v]>=3)hBombs++;
                    if(bad>0) AUDIO.play('suffocated');
                    let tMult = mult * Math.pow(2,bad) * Math.pow(2,hBombs);
                    if (p.hand.length >= 5) { tMult *= 2; badges += " üîí"; }
                    if(tMult>1) dMult=`x${tMult}`; if(hBombs>0) badges+=" üí£";
                    cost = p.hand.length * tMult; p.chips-=cost; pot+=cost;
                }
                list.innerHTML+=`<div class="result-row ${isWin?'winner':''}"><span>${p.name}</span><span>${p.hand.length} card(s) <span style="color:red;font-weight:bold">${dMult}</span>${badges}</span><span class="gain ${isWin?'plus':'minus'}">${isWin?'WIN':'-'+cost}</span></div>`;
            });
            STATE.players[wIdx].chips+=pot; document.querySelector('.result-row.winner .gain').innerText='+'+pot;
            document.getElementById('settlement-modal').classList.add('active');
            document.getElementById('next-round-btn').style.display = (NET.mode==='client') ? 'none' : 'inline-block';
            document.getElementById('wait-host-msg').style.display = (NET.mode==='client') ? 'block' : 'none';
            UI.updateInfo(); if(NET.mode==='host') this.syncState('SETTLE');
        },
        groupHand: function(h) {
            let a=h.map((c,i)=>({...c,oIdx:i,u:false})),b=[],p=[],s=[],st=[],cp=[],r=[],j=a.filter(c=>c.isJoker);
            if(j.length===2){r.push({type:'rocket',val:99,count:2,idxs:j.map(c=>c.oIdx)});j.forEach(c=>c.u=true);}
            let cnt={}; a.forEach(c=>{if(!c.u)cnt[c.val]=(cnt[c.val]||0)+1});
            for(let v in cnt)if(cnt[v]>=3){let cs=a.filter(c=>!c.u&&c.val==v);b.push({type:'bomb',val:parseInt(v),count:cs.length,idxs:cs.map(c=>c.oIdx)});cs.forEach(c=>c.u=true);}
            cnt={}; a.forEach(c=>{if(!c.u)cnt[c.val]=(cnt[c.val]||0)+1});
            for(let v in cnt)if(cnt[v]===2){let cs=a.filter(c=>!c.u&&c.val==v);p.push({type:'pair',val:parseInt(v),count:2,idxs:cs.map(c=>c.oIdx)});cs.forEach(c=>c.u=true);}
            a.forEach(c=>{if(!c.u&&!c.isJoker)s.push({type:'single',val:c.val,count:1,idxs:[c.oIdx]})});
            return {straights:st,consecPairs:cp,bombs:b,pairs:p,singles:s,rockets:r};
        },
        syncState: function(reason) {
            if(NET.mode==='host') NET.broadcast({type:'STATE',state:STATE,reason:reason});
            UI.renderLayout(); UI.renderHand(); UI.updateInfo(); UI.showTurnNotify(STATE.currTurn);
        },
        onNetworkData: function(data, senderConn) {
            if(NET.mode==='client') {
                if(data.type==='GAME_START') { 
                    STATE.players=data.players; STATE.playerCount=data.playerCount;
                    let myP = STATE.players.find(p => p.peerId === NET.peer.id);
                    this.myPlayerIdx=myP?myP.id:-1;
                    if(NET.hostConn&&NET.hostConn.peer) NET.myPin = NET.hostConn.peer.replace(CONFIG.APP_PREFIX, '');
                    this.start(); 
                }
                else if(data.type==='STATE') {
                    STATE.players=data.state.players; STATE.deck=data.state.deck; STATE.currTurn=data.state.currTurn; STATE.lastPlay=data.state.lastPlay; STATE.passCount=data.state.passCount; STATE.bombCount=data.state.bombCount;
                    if(data.reason==='RESET_ROUND') { document.getElementById('settlement-modal').classList.remove('active'); UI.showBubble(STATE.currTurn, "ÂèëÁâå‰∫Ü"); }
                    if(data.reason==='SETTLE') this.settle(STATE.currTurn);
                    UI.updateInfo(); UI.renderLayout(); UI.renderHand(); UI.showTurnNotify(STATE.currTurn);
                    if(STATE.currTurn===this.myPlayerIdx) { document.getElementById('player-controls').classList.add('active'); this.checkHumanButtons(); } else document.getElementById('player-controls').classList.remove('active');
                }
                else if(data.type==='EVENT') {
                    if(data.name==='THROW') { AUDIO.play(data.sound); UI.animThrow(data.pIdx, data.cards, ()=>UI.renderPlayedCards(data.pIdx, data.cards)); }
                    else if(data.name==='PASS') { AUDIO.play('pass'); UI.showBubble(data.pIdx, "‰∏çË¶Å"); }
                    else if(data.name==='SWEEP') { UI.showBubble(data.pIdx, "Ëµ¢‰∫ÜÔºÅ"); UI.animSweep(); }
                }
            } else if(NET.mode==='host' && data.type==='ACTION') {
                let client=NET.clients.find(c=>c.conn===senderConn), pIdx=STATE.players.findIndex(p=>p.peerId===client.id);
                if(pIdx===STATE.currTurn) { if(data.action==='play')this.turnEnd('play',data.cards); else this.turnEnd('pass'); }
            }
        },
        quit: function() { location.reload(); }
    };
</script>
</body>
</html>